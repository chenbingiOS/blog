---
layout:     post
title:      "不用临时变量交换两个数"
subtitle:   "Swap Two Variables Without Using a Temp Variable"
date:       2017-11-15
author:     "ChenBing"
header-img: "img/post-bg-touch.jpg"
header-mask: 0.3
tags:		  [C,Swap]
---

# 不用临时变量实现 swap(a,b) 

不使用临时变量的情况下，交换两个数字的方法

## 加减法
实现
```
a = a + b;  // a =  5 + 8 = 13
b = a - b;  // b = 13 - 8 = 5
a = a - b;  // a = 13 - 5 = 8
```
详解
```
a1 = a + b;
 b = a1 - b = a + b - b = a;
 a = a1 - b = a + b - a = b;
```

![img](/img/in-post/post-swap-num/post-swap-num-1.png)

用加减法可以处理整型，浮点型数值，需要考虑溢出问题（精度损失）。

<h2 id="overflowProblem">溢出问题</h2>
因为 C 语言数据类型区分 short int float, unsigned short unsigned int, 即识别正数，负数。

对于正数，反码，补码与原码相同。 
<br>对于负数，补码是原码的符号位不变，数值部分按位取反再加1

以 short 举例
<br>short 型数据是 16 位表示最高位是符号位，所以只有 15 位表示数值。
<br>15位 000000000000000 - 111111111111111 表示的范围是0 ~ 32767，
<br>加上最高位的符号位（第16位），就可以表示 -32768 ~ 32767 。
<br>unsigned short 型数据是 16 位都用来表示数值，
<br>16位0000000000000000 - 1111111111111111 表示的范围是 0 ~ 65535。

计算机在进行计算时是用补数计算的，且如果溢出会进行丢位处理。
<br>short 型最正数 32767 补码是 0111111111111111 加1后为 1000000000000000（注意最高位是符号位），1000000000000000 正是 -32768 的补数。
<br>unsigned short 型数据无符号最大数 65535 为 1111111111111111（16位），加1后为 10000000000000000（17位）计算机判断溢出后丢弃第17位，变为 0000000000000000 就是 0

## 异或法
实现
```
a = a ^ b;
b = b ^ a;
a = a ^ b;
```
详解
```
a1 = a ^ b;
 b = b ^ a1 = b ^ a ^ b = a;
 a = a1 ^ b = a ^ b ^ a = b;
```
![img](/img/in-post/post-swap-num/post-swap-num-1.png)

异或方式同样需要考虑[溢出问题](#overflowProblem)（精度损失）。
<br>异或的方式是将数字转换为二进制进行异或处理。
<br>异或二进制数规则，相同为零，不同为1

明细
```
          8 4 2 1			

5  二进制  0 1 0 1
8  二进制  1 0 0 0
-----------------
xor       1 1 0 1    -->  a1 = 13

8  二进制  1 0 0 0
13 二进制  1 1 0 1
-----------------
xor       0 1 0 1    -->  b = 5

13 二进制  1 1 0 1
5  二进制  0 1 0 1
-----------------
xor       1 0 0 0    -->  a = 8
```



